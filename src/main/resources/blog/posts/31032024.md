# Let's build

So, the tech.
Oh yes, the most important part — the tech.
I'm going to use stuff I'm most comfortable with, which is happened to be the most widespread tech stack in the world:
Angular frontend, Java+String backend, and everything runs top of AWS.

Let's begin with infrastructure — to keep things simple, I'm using AWS Amplify to run frontend, and AWS AppRunner to run
backend.
For now, there's no need for anything more complex than this.

### AWS Amplify

AWS Amplify hooks up to frontend repository via GitHub webhook.
And everytime anything is pushed into `main` branch, Amplify gets notified and the CI/CD machinery kicks in.
Amplify is smart enough to understand that it is connected to angular app (this actually doesn't matter,
because it builds a project with a silly `npm run build` script).

Built artifact is then stored into AWS S3 bucket
(unfortunately, or not, this bucket is not accessible)
and then exposed via cloudfront distribution(also not accessible).
By "not accessible" I mean that it's not created under my account, I can't look at it nor touch it.
It exists, but somewhere within the bowels of AWS.
Serverless, right?
AWS S3 is a perfect place for frontend artifacts – infinitely scalable, ultimately robust, publicly accessible(when
needed), cheap.
I have a strong impression that AWS S3 powers at least half of the internet,
and so I'm trusting it to host my frontend.

### AWS AppRunner

After the first blog post, I had no backend for my blog application.

— "Do I even need a backend?" - was my question.

— "Of course, I'm a backend developer, I have to have a backend." — Alright, let's have it.

Building backend is not a problem. The question is "How to run it?"

EKS?
Hell no, I'm not touching Kubernetes.
I'm sick of it.
It's too complex.
Moreover, I want to run a single container.
To say that EKS is an overkill in this situation is a huge understatement.

ECS?
Sounds better.
Let's do it.
I've created a cluster, task definition, created a task... and nothing.
I can access my service from the outside.
Oh, no... networking.
Something is not right with the VPC setup.
Subset seems fine.
Security groups and routing are also "looks fine."
Damn it, some silly detail is not right, and I can't find it.
Screw it — a task stopped, task definition deleted, cluster deleted.
ECS is also too complex.

While already in bed and half asleep, I was browsing through AWS console on my phone.
Eureka!
AWS Q. AWS AI assistant.
This is exactly what they built it for — so that idiots like me could ask questions like mine.
The answer was almost instant — AWS AppRunner.
Next morning I logged in into AWS AppRunner, clicked a few buttons, use this image from ECR, "deploy" and... it worked.
My hello world backend is running in a matter of 2–3 minutes.
This is why I love AWS.

I've hidden it via a custom domain `api.buyallmemes.com` by fiddling with Route 53 hosted zone.
Thankfully, I know a couple of tricks with DNS.

Now, it's time to build a backend.

### Java + Spring = ❤️

The choice of tech for the backend is super easy. There's no choice really.
There's only one true kind, and it's Java + Spring.
For now, I'm settling with an extremely simple setup: one REST endpoint that returns a list of posts.
What is a post?
A simple resource with only one attribute — content.
For now, I don't need anything else.
However, I do need something —
Zalando Problem library https://github.com/zalando/problem. I'm sure
you're aware about Zalando as an internet cloth retail store, but you might not be aware that they have quite a few cool
bits of software.
Problem Library is one of those bits — use it, do yourself a favor.
Another one is a RESTful API Guidelines https://opensource.zalando.com/restful-api-guidelines/ — read it.
It's awesome.

So, after the initial setup, I throw a bunch of code in. 
Rule #1: Fist, make it work, then make it right, then make it fast.

I don't care about performance at the moment(if ever), so I will ignore the latter part.
Let's focus on making things work.

Damn it, I need a database to store posts!
Or do I?
Hmm, why the hell would I need an enterprise grade DB (like PostgreSQL) to store a single freaking post.
I will store it on disk as part of the source code!
My IDE is a perfect .MD editor.
Git will provide me with all the version control I need.
I can just branch out of the `main`, write whatever I want, and then merge it back when it's ready to be published.
And it's free!

Well, I need to redeploy the backend every time I write or change the post,
but for now, this is not a big deal, so this mechanism will suffice.
I've set AppRunner to automatically detect and deploy the newest image versions of my backend.
So I don't have to do much manual stuff, besides building an image.

Btw, how am I supposed to build and push image into ECR?
I'm not writing Dockerfile — that's for sure.
Google Jib, https://github.com/GoogleContainerTools/jib.

I'm just dropping a jib gradle plugin declaration into `build.gradle`(Gradle FTW!),
set `jib.from.image` parameter to `amazoncorretto:21-alpine`, set `jib.to.image` to my ECR repo.
Quick `aws ecr get-login-password...` from ECR documentation, `./gradlew jib` and off flies my images. 

I will automate it later.
I think GitHub Actions is what cool kids are using (I'm more of a GitLab user,
but for the sake of exercise, I decided to publish everything on GitHub).












